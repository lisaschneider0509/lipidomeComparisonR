---
title: "Meat comparison report"
author: "Lisa Schneider"
date: "April 10, 2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Installation and namespaces
The files with the self-written functions for this workflow are loaded with source(). The first source-file "install_packages_lipidome_comparison.R" contains a function that installs all required packages. The installed packages are loaded into the namespace with library(). 
```{r load_packages, include=TRUE, warning=FALSE, message=FALSE}
## installation script for all used packages
source("install_packages_lipidome_comparison.R")
# install_packages_lipidome_comparison() # installs all reqired packages for this workflow 

## general
library(dplyr) # select part of data
library(stringr) # count separators
library(data.table) # transpose data frame
library(tibble) # data frame manipulation
library(imputeLCMD) # various imputation procedures, including left censored imputation
library(impute) # dependecy for imputeLCMD
## General graphics
library(ggplot2) # plots
library(viridis) # colorblind save color schemes
library(GGally) # paralell plot
library(fmsb) # spider chart
library(scales) # scale opacity of filling (alpha)
library(ggrepel) # avoids overlapping labels in ggplot graphs
# library(gridExtra) # arranging ggplots 
library(ggpubr)
## PCA
library(FactoMineR)
library(factoextra) # graphs for PCA
library(ggfortify) # biplot with ggplot
library(corrplot)
## clustering
library(heatmaply) # interactive heatmap
library(gplots) # heatmap
library(plotly) # interactive ggplots
library(dendextend)

## self written functions
source("lipidome_comparison_dataTransformaions.R")
source("lipidome_comparison_EDA.R")
source("lipidome_comparison_pca.R")
source("lipidome_comparison_clustering.R")
source("lipidome_comparison_hypothesis_testing.R")

```

```{r set_layout, include=FALSE}
my_theme <- theme_set(
  theme_minimal() +
    theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
          plot.subtitle = element_text(size = 8, hjust = 0.5, family = "AvantGarde", colour = "grey40"),
          axis.text.x = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          axis.text.y = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
          axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
          legend.text = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          legend.title = element_text(size = 10, colour = "grey40", family="AvantGarde"))
)
```

## Set directorys
This is set for my system. The syntax for windows is slightly different. Making this work on all systems, maybe from command line is planned for later. 

```{r set_paths}
working_directory <- "/home/lisa/FH/Masterarbeit/LipidomeComparison"
setwd(working_directory)

test_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/Probe-Datensatz_lisa.csv"
meat_data_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/meat_fish_final_raw.csv"

plot_path <- paste(working_directory, "/plots", sep = "")
plot_name <- paste(plot_path, "/meat_data", sep = "")
```

## A lot of data preprocessing
The meat data was used without preprocessing, except exproting the excel sheet to csv. The data was read from csv to the script and stripped of meta data. The string "N/F" for not identified lipids was replaced with NA and the data was separated in target data and internal standard data. The target data was then re-formatted, with the compounds as the columns and the sample IDs as the rows. The used function flip_df()  is from the "lipidome_comparison_dataTransformaions.R" file. 
Metadata was extracted from the sample IDs and the data set was separated by extraction method (AS and N). 

```{r data_preprocessing}
meat_data <- read.csv(meat_data_path, sep = ",", dec = ".", header = TRUE)
meat_data <- subset(meat_data, select = c(Compound, Type, Filename, Status, Group, Area))
meat_data <- subset(meat_data, Status == "Processed")
meat_data[meat_data==''] <- NA
meat_data[meat_data=='N/F'] <- NA
meat_data$Area <- as.numeric(meat_data$Area)
meat_target <- subset(meat_data, Type == "Target Compound")
meat_standard <- subset(meat_data, Type == "Internal Standard")

meat_target <- flip_df(meat_target)

meat_target <- subset(meat_target, !is.na(Group))
meat_target$SID <- sub(".*probe","sample", meat_target$SID)
meat_target$SID <- sub("\\.*pos2","2", meat_target$SID)
meat_target$SID <- sub("\\.*pos","1", meat_target$SID)

meat_AS <- meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] 
meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] <- sub(".*sample","AS_sample", meat_AS)
meat_N <- meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] 
meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] <- sub(".*sample","N_sample", meat_N)
meat_target$SID <- str_remove(meat_target$SID, "_AS")

meta_info <- read.table(text = meat_target$SID, sep = "_")
colnames(meta_info) <- c("Treatment", "Sample_nr", "Biol_rep", "Tech_rep")
meta_info$Biol_rep <- paste(meta_info$Sample_nr, meta_info$Biol_rep, sep = "_")
meta_info$Tech_rep <- paste(meta_info$Biol_rep, meta_info$Tech_rep, sep = "_")

meat_target <- cbind(meat_target$SID, meta_info, meat_target[, -1])
meat_target <- droplevels(meat_target)
levels(meat_target$Group)[levels(meat_target$Group) == "fleisch"] <- "meat"
levels(meat_target$Group)[levels(meat_target$Group) == "wild"] <- "game"
levels(meat_target$Group)[levels(meat_target$Group) == "FISCH"] <- "fish"
colnames(meat_target) <- c("SID", colnames(meat_target[-1]))
head(meat_target[1:7], 3)
meat_N <- subset(meat_target, Treatment == "N")
meat_AS <- subset(meat_target, Treatment == "AS")
```

## Data imputation
It can be assumed that most of the missing values are due to the concentration being below the detection limit. Therefore the missing values are considdered non-random and left-censored. 
Imputation only works up to a certain percentage of missing values, without changing the results. I found 20% missing values in the literature (Gurke, 2019, doi: 10.3389/fpsyt.2019.00041), therefore all compounds with more than 20% missing values were filtered. 
The remaining missing values where imputed using the QRILC (Quantile Regression Imputation of Left-Censored data) procedure. This procedure has the disadvantage of producing negative values (because it performs random draws from a distribution), which is a problem for the calculation of the log2 foldchange (I'm working on that). 

```{r imputation}
# remove columns where > 20% of the values are missing
impute_meat <- meat_N[, which(colMeans(!is.na(meat_N)) > 0.8)] 
impute_meat <- as.matrix(select_if(impute_meat, is.numeric))

# perform missing data imputation
meat_QRILC <- impute.QRILC(impute_meat, tune.sigma = 1) #todo constraints agains negative values
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
head(meat_imputed[1:7], 3)
```

## Reducing the replicates
To not artificially produce more samples than we hat and to reduce variation in preprocessing and measurement the means for each sample or biological replicate are calculated. 
The idea is, to continue working with these values, but in most cases this reduces the sample number below a point where most procedures work (n[fish] = 1 ). So in the for now I continued working with the non reduced data.  
The self-wirtten functions in this part are in "lipidome_comparison_dataTransformaions.R" and "lipidome_comparison_EDA.R".

```{r replicate redunction}
meat_groups <- generate_categorical_table(meat_imputed$Group) 
meat_treatment <- generate_categorical_table(meat_imputed$Treatment)

meat_numeric <- meat_imputed
meat_numeric$Group <- as.numeric(meat_numeric$Group)
meat_biol <- calc_by_replicate(meat_numeric, meat_numeric$Sample_nr, mean)
meat_tech <- calc_by_replicate(meat_numeric, meat_numeric$Biol_rep, mean)

new_meat_biol <- paste_catecorical_variable(meat_biol, 2, meat_groups)
head(new_meat_biol[1:7], 3)
new_meat_biol <- paste_catecorical_variable(meat_tech, 2, meat_groups)
head(new_meat_biol[1:7], 3)
```

## Exploratory data analysis 
Exploratory data analysis was performed graphically and using the shapiro-wilk test. 
The graphical data analysis (using qqplot, histogram and boxplot) turned out not to be verry practical due to the number of compounds, but it gives a good overview over the distributions of the variables. It showed, that some of the variables had normal distribution, while others where multi modal. Therefor the results of the following tests for normal distribution and correlation have to be handelled carefully. 
All the graphs are in a separate zip-folder due to thier size and runtime. 

```{r eda_graphical, include=FALSE}
### graphical exploratory data analysis
qqplot_by_factor(meat_imputed, "Group", out_path = plot_name)
histogram_by_factor(meat_imputed, "Group", out_path = plot_name)
boxplot_by_factor(meat_imputed, "Group", out_path = plot_name)
```

```{r eda}
### test for normality
meat_normality <- shapiro_by_factor(meat_imputed, meat_imputed$Group)
head(meat_normality[1:7], 3)

### test for correlation
meat_correlation <- cor(select_if(meat_imputed, is.numeric), method = "spearman")
head(meat_correlation[1:7], 3)
correlation_heatmap(meat_imputed, interactive = FALSE)
```

## Principal component analysis
The selection of the number of principal components depends on the explained variance displayed by get_eigenvalue() and the scree plots. There are two different representations of the scree plots, because I find both of them useful. Unfortunately in our data each PC only explains a small percentage of variance, PC1 and PC2 together explain only about 36%, therefore this model is not ideal. 
The problem with the separation is also visible in the biplots. While the fish-values are close together (due to them being replicates of the same sample) and well separated from the other groups, there is almost no separation between meat and game. 
The last two plots show which compounds have the highest contribution to the principal components. The matrix gives an overview over all five principal components and all variables. Due to the number of cmponents, the elements of the plot are verry small. A better representation are the barcharts for the top ten contributions to a selected number of principal components (I plottet PC1 and PC2). With this information the number of varibles can be reduced, for example 
for a parallel plot, a spider plot or for hypothesis generation and testing. 

```{r PCA_scree, fig.height = 4}
meat_pca <- PCA(select_if(meat_imputed, is.numeric), scale.unit = TRUE, graph = FALSE)
meat_eigenvalue <- get_eigenvalue(meat_pca)
head(meat_eigenvalue, 3)

scree_factoextra(meat_pca)
scree_base(select_if(meat_imputed, is.numeric))
```

```{r PCA_biplot}
biplot_ggplot2(meat_imputed, "Group", loadings = FALSE, ellipse = TRUE, scale = TRUE)
# biplot_factoextra(meat_pca, meat_imputed$Group, ellipse = TRUE)
```

```{r PCA_contrib}
plot_contrib_to_pc(meat_pca)

pc1_contrib_plot <- fviz_contrib(meat_pca, choice = "var", axes = 1, top = 10, 
             fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3), 
             ggtheme = my_theme)

pc2_contrib_plot <- fviz_contrib(meat_pca, choice = "var", axes = 2, top = 10, 
             fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3), 
             ggtheme = my_theme,  
             linecolor = "black")


ggarrange(pc1_contrib_plot, pc2_contrib_plot, ncol = 2, nrow = 1, align = "h", widths = c(0.9, 0.9))
```

```{r after_PCA, height = 6}
meat_var <- meat_pca$var
meat_contrib <- as.data.frame(meat_var$contrib)
pc1_contrib_table <- meat_contrib[order(meat_contrib$Dim.1, decreasing = TRUE),]
pc1_contrib <- rownames(pc1_contrib_table)[1:10]
pc2_contrib_table <- meat_contrib[order(meat_contrib$Dim.2, decreasing = TRUE),]
pc2_contrib <- rownames(pc2_contrib_table)[1:10]
meat_pca_sub <- subset(meat_imputed, select = c("Sample_nr", "Group", pc1_contrib, pc2_contrib))

parallel_plot(meat_pca_sub, meat_pca_sub$Group)

means_meat_pca <- calc_by_replicate(meat_pca_sub, meat_pca_sub$Group, funct = mean)
spider_chart(means_meat_pca)
```

## Hierarchical clustering 
The functions hclust_performance_table and hclust_performance_plot both use the dend_expend function to find the best performing distance and hierarchical clustering methods. The barplot displays the values from the "optim" column graphically. In hierarchical clustering, game is put in one cluster and meat and fish are clustered together. In the heatmap it is visible, that there are two different groups of game. In the zip-folder with the EDA-plots there is also a html-file for the interactive heatmap, because printing it into pdf did not work. 
```{r clustering, warning=FALSE}
meat_clust <- data.frame(Group = meat_imputed$Group)
meat_clust <- cbind(meat_clust, select_if(meat_imputed, is.numeric))
rownames(meat_clust) <- meat_imputed$SID

hclust_performance_table(meat_clust)
hclust_performance_plot(meat_clust)

meat_dist <- dist(select_if(meat_clust, is.numeric), method = "manhattan")
meat_hclust <- hclust(meat_dist, method = "average")
hclust_dendrogram(meat_hclust, 
                  labs = paste(meat_imputed$Sample_nr, 
                               meat_clust$Group, sep = "-"))

hclust_heatmap(meat_clust,
               dist_method = "manhattan",
               hclust_method = "averagelevels(fish_vs_meat_game$Group",
               row_names = meat_clust$Group)
# hclust_heatmap_interactive(meat_clust,
#                            dist_method = "manhattan",
#                            hclust_method = "average", 
#                            html_path = "meat_heatmap.html")
```

## Hypothesis testing and volcano plot
To find variables with a significant difference in at least one group, Kruskal-Wallis-test (because not all variabels were normally distributed) was performed column-wise. The resulting table can be used to select the significant variables of the original data frame for further analysis. 

The volcano plots were performed for two groups each. The significance was assessed using the Wilcox rank sum test (again because of the missing normal distribution in some variables). In addition a multiple testing correction using FDR was performed. Log2-foldchange was calculated by performing log2 for all variables in both groups and then subtracting the test-group from the control-group values. There is a problem with the negative values imputed by impute.QRILC (I am working on finding out how to constrain the imputation method so it does not impute negative values): The log2-function produces NaNs from negative values. Until the imputation problem is solved, the variables with NaNs are excluded. 

The volcano_plot function prints a dotplot with the log2-foldchange on the x-axis and the negative log10 of the p-value on the y-axis. The significant up- or down regulated lipids are colored and labelled. Because the number of variables is relatively low for a volcano plot (85 variables), the shape does not resemble a volcano, this should be improved with an increasing number of identified lipids. 
```{r hypothesis testing, message=FALSE, warning=FALSE}
# kruskal-wallis 
meat_kruskal <- kruskal_test_by_col(meat_imputed, "Group")
meat_kruskal$p_adj <- p.adjust(meat_kruskal$p_value, method = "fdr")
meat_significant <- subset(meat_kruskal, meat_kruskal$p_value <= 0.05)
head(meat_significant, 3)

# fish vs meat & game volcano plot
fish_vs_meat_game <- meat_imputed
levels(fish_vs_meat_game$Group)[levels(fish_vs_meat_game$Group) == "meat" | 
                                  levels(fish_vs_meat_game$Group) == "game"] <- "meat/game"

p_fish_vs_meat_game <- one_sample_test_by_col(fish_vs_meat_game, fish_vs_meat_game$Group, method = wilcox.test)
adj_fish_vs_meat_game <- p.adjust(p_fish_vs_meat_game$p_values, method = "fdr")
fc_fish_vs_meat_game <- log2_foldchange(fish_vs_meat_game, 
                                   fish_vs_meat_game$Group, 
                                   control_group = "fish", 
                                   test_group = "meat/game")

volcano_df <- data.frame(p_value = p_fish_vs_meat_game, adj_p_value = adj_fish_vs_meat_game, log2_foldchange = fc_fish_vs_meat_game)
volcano_df <- volcano_df[complete.cases(volcano_df),]

volcano_plot(volcano_df,
             foldchange_col = volcano_df$log2_foldchange,
             significance_col = volcano_df$adj_p_value,
             foldchange = 1,
             significance = 0.05,
             title = "Fish vs. meat and game")


# meat vs fish volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)

p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish$p_values, method = "fdr")
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, 
                                   meat_vs_fish$Group, 
                                   control_group = "fish", 
                                   test_group = "meat")

volcano_df <- data.frame(p_value = p_meat_vs_fish, adj_p_value = adj_meat_vs_fish, log2_foldchange = fc_meat_vs_fish)
volcano_df <-volcano_df[complete.cases(volcano_df),]

volcano_plot(volcano_df, 
             foldchange_col = volcano_df$log2_foldchange, 
             significance_col = volcano_df$adj_p_value, 
             foldchange = 1, 
             significance = 0.05,
             title = "Fish vs. meat")

# meat vs game volcano plot
meat_vs_game <- subset(meat_imputed, Group == "game" | Group == "meat")
meat_vs_game <- droplevels(meat_vs_game)

p_meat_vs_game <- one_sample_test_by_col(meat_vs_game, meat_vs_game$Group, method = wilcox.test)
adj_meat_vs_game <- p.adjust(p_meat_vs_game$p_values, method = "fdr")
fc_meat_vs_game <- log2_foldchange(meat_vs_game, 
                                   meat_vs_game$Group, 
                                   control_group = "meat", 
                                   test_group = "game")

volcano_df <- data.frame(p_value = p_meat_vs_game, adj_p_value = adj_meat_vs_game, log2_foldchange = fc_meat_vs_game)
volcano_df <- volcano_df[complete.cases(volcano_df),]

volcano_plot(volcano_df, 
             foldchange_col = volcano_df$log2_foldchange, 
             significance_col = volcano_df$adj_p_value, 
             foldchange = 1, 
             title = "Meat vs. game")

# game vs fish volcano plot
game_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "game")
game_vs_fish <- droplevels(game_vs_fish)

p_game_vs_fish <- one_sample_test_by_col(game_vs_fish, game_vs_fish$Group, method = wilcox.test)
adj_game_vs_fish <- p.adjust(p_game_vs_fish$p_values, method = "fdr")
fc_game_vs_fish <- log2_foldchange(game_vs_fish, 
                                   game_vs_fish$Group, 
                                   control_group = "fish", 
                                   test_group = "game")

volcano_df <- data.frame(p_value = p_game_vs_fish, adj_p_value = adj_game_vs_fish, log2_foldchange = fc_game_vs_fish)
volcano_df <- volcano_df[complete.cases(volcano_df),]

volcano_plot(volcano_df, 
             foldchange_col = volcano_df$log2_foldchange, 
             significance_col = volcano_df$adj_p_value, 
             foldchange = 1, 
             significance = 0.05,
             title = "Fish vs. game")

```

## Outlook
* Fix imputation of negative values
* Play around with normalization methods 
* Supervised learning with random forest: 
    + Makes sense for establishing if and how the kind of meat can be predicted, because we already have training data.
    + Variable selection is already implemented in the randomForest r-ackage. 
    + The only problem is that there is only one small data set, which might be to small to produce training and test data.
* Add option to easily run the workflow (either as a shiny app or commandline interface)
* Prepare installation script for dependencies that works on windows as well

