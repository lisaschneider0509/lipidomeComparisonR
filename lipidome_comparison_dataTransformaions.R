#### R script with functions for lipidome comparison ####

### Data handelling ###

my_theme <- theme_set(
  theme_minimal() +
    theme(plot.title = element_text(size=12, hjust = 0.5),
          axis.text.x = element_text(size = 8),
          # axis.title = element_text(size = 10),
          axis.title.x = element_text(size = 10, hjust = 0.5),
          axis.title.y = element_text(size = 10, hjust = 0.5),
          legend.text = element_text(size = 8),
          legend.title = element_text(size = 10))
)


#' Transpose data frame with correct row- and column names.
#' 
#' @description 
#' `pretty_transpose` transposes a data frame to a new data frame
#' @details 
#' This function takes a data frame, transposes it and sets the former first column as the column names. 
#' Row names are automatically generated by the data.table::transpose() function. 
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(cbind(c("ID", "a", "b", "c", "d"), c("z", 1, 2, 3, 4), c("x", 5, 6, 7, 8)))
#' pretty_transpose(df)
pretty_transpose <- function(input_df){
  t_input_df <- data.table::transpose(as.data.table(input_df), make.names = 1)
  t_input_df <- as.data.frame(t_input_df)
  row.names(t_input_df) <- colnames(input_df[-1])
  t_input_df
}

#' Flip data frame
#' 
#' @description `flip_df` takes a data frame with the columns c(Compound, Type, Filename, Status, Group, Area)
#' and transposes it, so that each area value is assigned to one compound (columnwise) and one SID (rowwise). 
#' Additionally the group variable is saved to each sample.  Suitable for preprocessed csvs generated by Thermo Fisher Tracefinder. 
#' @param df data frame. Contains the columns c(Compound, Type, Filename, Status, Group, Area). 
#' @example 
#' \dontrun
#' dir <- paste(getwd(), "/example_data/tracefinder_example.csv", sep = "")
#' tf_data <- read.csv(dir)
#' flip_df(tf_data)
flip_df <- function(df){
  sample <- levels(df$Filename)
  new_df <- data.frame()
  for(i in 1:length(sample)){
    buffer <- subset(df, Filename == sample[i])
    buffer_df <- subset(buffer, select = c(Compound, Area))
    t_buffer_df <- pretty_transpose(buffer_df)
    t_buffer_df <- add_column(t_buffer_df, SID = sample[i], .before = 1)
    # t_buffer_df <- add_column(t_buffer_df, Group = buffer$Group[1], .after = 1)
    new_df <- rbind(new_df, t_buffer_df)
    rownames(new_df)[i] <- i
  }
  new_df
}

#' Flip data frame for lipidr
#' 
#' @description `flip_df_for_lipidr` takes a data frame with the columns c(Compound, Filename, Area)
#' and transposes it, so that each area value is assigned to one compound (rowwise) and one sample (Filename) (columnwise). 
#' Suitable for preprocessed csvs generated by Thermo Fisher Tracefinder. The resulting data frame can be used with the bioconductor package lipidr. 
#' @param df data frame. Contains the columns c(Compound, Filename, Area). 
#' @example 
#' \dontrun
#' dir <- paste(getwd(), "/example_data/tracefinder_example.csv", sep = "")
#' tf_data <- read.csv(dir)
#' flip_df_for_lipidr(tf_data)
flip_df_for_lipidr <- function(df){
  df$Filename <- as.factor(df$Filename)
  df$Compound <- as.factor(df$Compound)
  df$Compound <- droplevels(df$Compound)
  
  compound <- levels(df$Compound)
  sample <- levels(df$Filename)
  new_df <- data.frame(compound = compound)
  for(i in 1:length(sample)){
    buffer_v <- df$Area
    new_df <- cbind(new_df, buffer_v)
    colnames(new_df)[i+1] <- sample[i]
  }
  new_df
}



#' Takes a data frame with specific rownames and extracts meta data from it
#' 
#' @description 
#' `SID_to_metadata` takes a data frame with rownames in the form of 
#' <experiment_treatment_biol.rep.nr_tech.rep.nr> 
#' and extracts meta data
#' @details 
#' This function takes the information saved in sample IDs of the form 
#' <experiment_treatment_biol.rep.nr_tech.rep.nr> and saves each 
#' part of the sample ID as a column of character strings. 
#' If one part is missing, the column is filled with NAs. 
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(rbind(c(1, 2, 3, 4), c(5, 6, 7, 8)))
#' row.names(df) <- c("Ex1_Tr1_1_1", "Ex1_Tr1_1_2")
#' colnames(df) <- c("a", "b", "c", "d")
#' ndf <- SID_to_metadata(df); ndf
SID_to_metadata <- function(input_df){
  n_sep <- mean(stringr::str_count(row.names(input_df), "_"))
  meta_info <- read.table(text = row.names(input_df), sep = "_")
  print(meta_info)
  if(n_sep == 2){
    biol_rep <- paste(meta_info$V1, meta_info$V2, sep = "_")
    treatment <- meta_info$V1
    input_df <- tibble::add_column(input_df, biol_replicate = biol_rep, .before = 1)
    input_df <- tibble::add_column(input_df, treatment = treatment, .before = 1)
    input_df <- tibble::add_column(input_df, experiment = NA, .before = 1)
  } else if(n_sep == 3){
    biol_rep <- paste(meta_info$V1, meta_info$V2, meta_info$V3, sep = "_")
    treatment <- meta_info$V2
    experiment <- meta_info$V1
    input_df <- tibble::add_column(input_df, biol_replicate = biol_rep, .before = 1)
    input_df <- tibble::add_column(input_df, treatment = treatment, .before = 1)
    input_df <- tibble::add_column(input_df, experiment = experiment, .before = 1)
  } else{
    print("Wrong format")
  }
}


#' Transform all columns with caracters of a data frame to factor
#' 
#' @description 
#' `character_to_factor` takes a data frame with character strings and numerics 
#' and transforms all columns with characters only to factor columns
#' @details
#' All the columns of a data frame that only have character strings in them
#' are transformed to factor columns.
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(rbind(c("Ex1", "TR1", 1, 2, 3, 4), c("Ex1", "Tr2", 5, 6, 7, 8)))
#' row.names(df) <- c("1", "2")
#' colnames(df) <- c("Ex", "Tr", "a", "b", "c", "d")
#' character_to_factor(df)
character_to_factor <- function(input_df){
  for(i in 1:ncol(input_df)){
    if (!is.numeric(input_df[,i])){
      input_df[,i] <- factor(input_df[,i])
    }
  }
  new_df <- input_df
}

#' Generate table of categorical variable
#' 
#' @description `generate_categorical_table` takes a categorical column of a data frame and generates a table where the 
#' categorical strings are assigned to a numeric code. This way the information of additional catecorical variabes is not lost when performing 
#' an aggregate function. 
#' @param categorical_col column of data frame containing categorical values (i.e. strings). Format = df$colname
generate_categorical_table <- function(categorical_col){
  categorical_table <- cbind.data.frame(as.vector(categorical_col), as.numeric(categorical_col))
  categorical_table <- as.data.frame(table(categorical_table))
  categorical_table <- categorical_table[categorical_table$Freq != 0,][,-3]
  colnames(categorical_table) <- c("V1", "V2")
  categorical_table
  
}

#' Paste categroical variable
#' 
#' @description `paste_catecorical_variable` takes a dataframe produced by the aggregate function, the column number of a categorical variable, that was transformed
#' to numeric before applying aggregate and a table with the information of the numeric codes and the strings of the categorical variable and pastes the strings into 
#' the aggregated data frame. This function works only if the categorial variable has less different attributes than the variable used in the aggregate function. 
#' @param aggregated_df data frame produced by the aggregate() function.
#' @param categorical_col integer. Column of the aggregated_df that contains a categorical variable that was transformed to numeric before applying aggregate. 
#' @param categorical_table data frame. Contains information <which numeric value was assigned to which categorical attribute string. Produced by generate_categorical_table() function. 
#' 
paste_catecorical_variable <- function(aggregated_df, categrical_col, categorical_table){
  
  new_df <- data.frame()
  for(i in 1:nrow(categorical_table)){
    for(j in 1:nrow(aggregated_df)){
      if(categorical_table$V2[i] == aggregated_df[j, categrical_col]){
        buffer <- data.frame(aggregated_df$Group.1[j], categorical_table$V1[i])
        new_df <- rbind(new_df, buffer)
      }
    }
  }
  colnames(new_df) <- c("V1", "V2")
  new_df <- new_df[with(new_df, order(V1)),  ]
  aggregated_df <- aggregated_df[with(aggregated_df, order(Group)), ]
  aggregated_final <- aggregated_df
  aggregated_final[, categrical_col] <- new_df$V2
  aggregated_final
}

