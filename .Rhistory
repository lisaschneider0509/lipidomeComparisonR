method = method,
hist.col = colour[2], rug = FALSE,
density = TRUE,  lm = TRUE, ci = FALSE, col = colour[1],
ellipses = FALSE,
pch = 20, cex = 0.7,
cex.cor = 0.5, main = "Correlation plot")
}
if(out_path != "none"){
print(paste("Saving to ", out_name, sep = ""))
png(out_name)
func()
dev.off()
func()
}
else{
func()
}
}
#' Matrix heatmap
#'
#' @description `matrix_heatmap` displays values of a matrix in a heatmap
#' @param input_matrix matrix. For exaple correlation or matrix of ratios or differences.
#' @param interactive logical. Print heatmap to device (FALSE, default)
#' or open interactive heatmap in browser (TRUE).
#' @param out_path string. Path to save heatmap to png.
#' If out_path is empty the heatmap is printed to the device.
#' @example
#' iris_cor <- cor(iris[,-5], method = "spearman")
#' matrix_heatmap(iris_cor)
#' \dontrun{
#' dir.create(paste(getwd(), "/examples", sep = ""), showWarnings = FALSE)
#' dir <- paste(getwd(), "/examples/iris", sep = "")
#' matrix_heatmap(iris_cor, interactive = TRUE)
#' matrix_heatmap(iris_cor, out_path = dir)
#' }
matrix_heatmap <- function(input_df,
title = "",
interactive = FALSE,
out_path = "none"){
melted_matrix <- reshape::melt(input_df)
names(melted_matrix) <- c("x", "y", "value")
head(melted_matrix)
matrix_heatmap <- ggplot(data = melted_matrix, aes(x=x, y=y, fill=value)) +
geom_tile() +
ggtitle(title) +
scale_fill_viridis_c(direction = -1) +
my_theme +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank(),
axis.text.y = element_text(size = 6),
axis.text.x = element_text(angle = 90, size = 6, hjust = 1))
if(out_path != "none"){
print(paste("Saving plot to ", out_path, "_matrix_heatmap.png", sep = ""))
ggsave(paste(out_path, "_matrix_heatmap.png", sep = ""),
plot = matrix_heatmap)
}
if (interactive == TRUE) {
plotly::ggplotly(matrix_heatmap) # interactive heatmap
} else {
matrix_heatmap # static heatmap
}
}
#' Calculate ratio matrix
#'
#' @description `calculate_ratio_matrix` takes a vector and calculates the ratio between all elements of a vector.
#' @param input_vector numeric vector.
#' @param names_vector vector. Length = length(input_vector). Row and column names for the returnded matrix. Default are numbers 1:length(input_vector).
#' @example
#' myvector <- c(1712.9583, 1446.4583, 1968.4167, 2124.1250, 2315.7083, 1135.1667, 2227.5000)
#' mynames <- letters[1:length(myvector)]
#' calculate_ratio_matrix(myvector, mynames)
calculate_ratio_matrix <- function(input_vector,
names_vector = 1:length(input_vector)){
ratio_matrix <- matrix(nrow = length(input_vector),
ncol = length(input_vector))
for(i in 1:length(input_vector)){
for(j in 1:length(input_vector)){
buffer <- input_vector[i] / input_vector[j]
ratio_matrix[i, j] <- buffer
}
}
rownames(ratio_matrix) <- names_vector
colnames(ratio_matrix) <- names_vector
ratio_matrix
}
#' Parallel coordinates plot
#'
#' @description `parallel_plot` prints a paralell coordinates plot using a data frame
#' @details This function takes a data frame with at least one factor variable and
#' displays #' it in a pralell coordinates plot, where the different groups are
#' color coded. This plot works best for <= 10 parameters.
#' @param input_df data frame.
#' @param groupColumn numeric. Column to sort by.
#' @param out_path string. Path to save parallel plot to png.
#' If out_path is empty the parallel plot is printed to the device.
#' @param titles a vector of strings.
#' 1. Main Title. Default = "Parallel plot"
#' 2. X-axis title. Default = ""
#' 3. Y-axis title. Default = ""
#' @param scale string. Method used to scale the variable. Default = "globalminmax".
#' Options: "std", "robust", "uniminmax", "globalminmax", "center", "centerObs".
#' For more information on the options see help(ggparcoord).
#' @example
#' parallel_plot(iris, iris$Species)
#' parallel_plot(iris, 5, scale = "center", titles = c("Centered parallel plot", "Parameters", "Univariate scale to standardize vertical height"))
#' \dontrun
#' dir.create(paste(getwd(), "/examples", sep = ""), showWarnings = FALSE)
#' dir <- paste(getwd(), "/examples/iris", sep = "")
#' parallel_plot(iris, 5, out_path = dir)
parallel_plot <- function(input_df,  group_vector, out_path = "none",
title = "Parallel Plot",
x_title = "",
y_title ="",
legend_title = "",
col_names = colnames(dplyr::select_if(input_df, is.numeric)),
scale = "globalminmax"){
new_df <- dplyr::select_if(input_df, is.numeric)
new_df <- cbind(new_df, group_vector)
par_plot <- ggparcoord(new_df,
columns = 1:(ncol(new_df)-1),
groupColumn = ncol(new_df),
showPoints = FALSE,
scale = scale, # "globalminmax" is default
alphaLines = 0.5
) +
ggtitle(title) +
xlab(x_title) +
ylab(y_title) +
labs(color = legend_title) +
scale_color_viridis(discrete=TRUE, end = 1) +
geom_point(shape = 20, size = 0.5) +
theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
axis.text.x = element_text(angle = 45, size = 7, hjust = 1, colour = "grey40", family="AvantGarde"),
axis.text.y = element_text(size = 7, colour = "grey40", family="AvantGarde"),
axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
legend.text = element_text(size = 7, colour = "grey40", family="AvantGarde"),
legend.title = element_text(size = 8, colour = "grey40", family="AvantGarde"))
if(out_path != "none"){
print(paste("Saving plot to ", out_path, "_parcoord.png", sep = ""))
ggsave(paste(out_path, "_parcoord.png", sep = ""),
plot = par_plot)
}
else{
par_plot
}
}
#' Spider Chart
#'
#' @description `spider chart` takes a minimized data frame (one value per group) and prints a spider chart
#' @details This function takes a data frame of with one value per group (i.e. calculate mean groupwise).
#' This minimized data frame is used to draw a spider chart (also radar chart odr network plot).
#' The ideal numer of parameters for a spider chart is <= 10. Also the shape of the graph depends on
#' the order of parameters. If the data has large differences in size, normalizing or scaling the data is necessary.
#' Doesn't work with non normal data.
#' @param minimized_df data frame. A data frame that contains only one value per group and variable.
#' Most often this will be a data frame of means calculated from another data frame.
#' @param tile string. Main title of the chart. Default = "Spider chart"
#' @param out_path string. Path to save spider chart to png.
#' If out_path is empty, the spider chart is printed to the device.
#' @example
#' minimized_iris <- aggregate(dplyr::select_if(iris, is.numeric),
#'                             by = list(iris$Species),
#'                             FUN = mean)
#' rownames(minimized_iris) <- minimized_iris$Group.1
#' spider_chart(minimized_iris, title = "Spider chart of iris", legend_lab = c(1, 2, 3))
#' \dontrun
#' minimized_iris <- aggregate(dplyr::select_if(iris, is.numeric),
#'                             by = list(iris$Species),
#'                             FUN = mean)
#' rownames(minimized_iris) <- minimized_iris$Group.1
#' dir.create(paste(getwd(), "/examples", sep = ""), showWarnings = FALSE)
#' dir <- paste(getwd(), "/examples/iris", sep = "")
#' spider_chart(minimized_iris, out_path = dir)
spider_chart <- function(minimized_df,
title = "Spider chart",
legend_lab = rownames(minimized_df),
out_path = "none"){ # todo get labels ot of the plot
out_name <- paste(out_path, "_spiderChart", ".png", sep = "")
func <- function(){
par(mfrow = c(1, 1))
spider_data <- dplyr::select_if(minimized_df, is.numeric) # remove column with rownames
spider_labels <- colnames(spider_data) # set max. label length to 10 characters
spider_min <- floor(min(spider_data))
spider_max <- ceiling(max(spider_data))
spider_interval <- (spider_max-spider_min)/4
spider_data <- as.data.frame(select_if(spider_data, is.numeric))
# add max and min to the dataframe to plot the grid
spider_data <- rbind(spider_min, spider_max, spider_data)
## set colors
colors_border = as.vector(viridis(n = nrow(minimized_df), option = "viridis"))
colors_in = alpha(colors_border, alpha = 0.1)
## radar chart
par(mfrow = c(1, 1))
radarchart(spider_data,
axistype=1,
caxislabels = c(spider_min,
spider_min+spider_interval,
spider_min+2*spider_interval,
spider_min+3*spider_interval,
spider_min+4*spider_interval),
#custom polygon
pcol=colors_border,
pfcol=colors_in,
pty = 20,
plwd=2,
plty=1,
# custom grid
cglcol="grey",
cglty=1,
axislabcol="grey",
cglwd=0.8,
# custom labels
vlcex=0.6,
vlabels = spider_labels,
centerzero = FALSE)
title(main = title, cex.main = 0.9, font.main = 1)
## Add a legend
legend(x=-2,
y=1.1,
legend = legend_lab,
bty = "n",
pch=20,
col=colors_border,
text.col = "black",
cex=0.7, pt.cex=1.3)
}
## print to device or save
if(out_path != "none"){
print(paste("Saving to ", out_name))
png(filename = out_name)
func()
dev.off()
}
else{
func()
}
}
heatmap_list <- list()
for(i in 1:length(ratio_list)){
buffer <- matrix_heatmap(ratio_list, title = names(ratio_list)[i], interactive = FALSE)
list_name <- names(ratio_list)[i]
heatmap_list[[list_name]] <- buffer
}
lipid_ratio_heatmaps <- ggarrange(plotlist = heatmap_list,
ncol = 2,
nrow = 4,
align = "h",
widths = c(0.9, 0.9),
common.legend = TRUE,
legend = "right")
lipid_ratio_heatmaps <- annotate_figure(lipid_ratio_heatmaps,
top = text_grob("Lipid ratios per sample",
size = 16, family = "AvantGarde"))
ggsave(filename = paste(plot_name, "_ratio_heatmap.png", sep = ""),
plot = lipid_ratio_heatmaps, width = 8, height = 12)
install.packages("PMCMRplus")
### load packages
library(dplyr) # select part of data
library(stringr) # count separators
library(data.table) # transpose data frame
library(impute)
library(imputeLCMD)
library(ggplot2)#, # plots
library(tibble) # data frame manipulation
library(viridis) # colorblind save color schemes
library(GGally) # paralell plot
library(fmsb) # spider chart
library(scales) # scale opacity of filling (alpha)
library(ggpubr) # multiple plots on one page
library(ggrepel)
library(factoextra)
library(ggfortify) # biplot with ggplot
library(corrplot)
library(FactoMineR)
library(heatmaply) # interactive heatmap
library(gplots) # heatmap
library(plotly) # interactive heatmap
library(dendextend)
# library(psych) # for correlation plot
# library(gridExtra)
# library(devtools)
# library(dendextend)
# library(limma) # hypothesis testing
source("lipidome_comparison_dataTransformaions.R")
source("lipidome_comparison_EDA.R")
source("lipidome_comparison_pca.R")
source("lipidome_comparison_clustering.R")
source("lipidome_comparison_hypothesis_testing.R")
# set ggplot theme
my_theme <- theme_set(
theme_minimal() +
theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
plot.subtitle = element_text(size = 8, hjust = 0.5, family = "AvantGarde", colour = "grey40"),
axis.text.x = element_text(size = 8, colour = "grey40", family="AvantGarde"),
axis.text.y = element_text(size = 8, colour = "grey40", family="AvantGarde"),
axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
legend.text = element_text(size = 8, colour = "grey40", family="AvantGarde"),
legend.title = element_text(size = 10, colour = "grey40", family="AvantGarde"))
)
## set variables
working_directory <- "/home/lisa/FH/Masterarbeit/LipidomeComparison"
setwd(working_directory)
test_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/Probe-Datensatz_lisa.csv"
meat_data_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/meat_fish_final_raw.csv"
plot_path <- paste(working_directory, "/plots", sep = "")
plot_name <- paste(plot_path, "/meat_data", sep = "")
## meat data
### data processing
meat_data <- read.csv(meat_data_path, sep = ",", dec = ".", header = TRUE)
meat_data <- subset(meat_data, select = c(Compound, Type, Filename, Status, Group, Area))
meat_data <- subset(meat_data, Status == "Processed")
# meat_data[meat_data==''] <- NA
meat_data[meat_data=='N/F'] <- NA
meat_data$Area <- as.numeric(meat_data$Area)
meat_target <- subset(meat_data, Type == "Target Compound")
meat_standard <- subset(meat_data, Type == "Internal Standard")
meat_target <- flip_df(meat_target)
meat_target$SID <- sub(".*probe","sample", meat_target$SID)
meat_target$SID <- sub("\\.*pos2","2", meat_target$SID)
meat_target$SID <- sub("\\.*pos","1", meat_target$SID)
meat_target <- subset(meat_target, str_detect(meat_target$SID, "sample") == TRUE)
meat_AS <- meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE]
meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] <- sub(".*sample","AS_sample", meat_AS)
meat_N <- meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE]
meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] <- sub(".*sample","N_sample", meat_N)
meat_target$SID <- str_remove(meat_target$SID, "_AS")
meta_info <- read.table(text = meat_target$SID, sep = "_")
colnames(meta_info) <- c("Treatment", "Sample_nr", "Biol_rep", "Tech_rep")
meta_info$Biol_rep <- paste(meta_info$Sample_nr, meta_info$Biol_rep, sep = "_")
meta_info$Tech_rep <- paste(meta_info$Biol_rep, meta_info$Tech_rep, sep = "_")
meat_target <- cbind(meat_target$SID, meta_info, meat_target[, -1])
meat_target <- droplevels(meat_target)
map <- data.frame(Sample_nr=c("sample1","sample2","sample3", "sample4", "sample5", "sample6", "sample7"),
Group_new=c("beef", "beef", "beef", "game", "game", "fish", "beef"))
meat_target <- left_join(meat_target, map, by="Sample_nr")
meat_target$Group <- meat_target$Group_new
meat_target <- meat_target[-ncol(meat_target)]
# levels(meat_target$Group)[levels(meat_target$Group) == "fleisch"] <- "meat"
# levels(meat_target$Group)[levels(meat_target$Group) == "wild"] <- "game"
# levels(meat_target$Group)[levels(meat_target$Group) == "FISCH"] <- "fish"
# colnames(meat_target) <- c("SID", colnames(meat_target[-1]))
# meat_N <- subset(meat_target, Treatment == "N")
# meat_AS <- subset(meat_target, Treatment == "AS")
meat_data <- meat_target
## Exploratory data analysis
### impute missing values #todo find option to avoid imputation of negative values
#### remove columns where all values are missing
impute_meat <- meat_data[, which(colMeans(!is.na(meat_data)) > 0.8)]
impute_meat <- as.matrix(select_if(impute_meat, is.numeric))
#### perform missing data imputation
# meat_imputed <- as.data.frame(impute.QRILC(impute_meat, tune.sigma = 1)[[1]])
meat_imputed <- as.data.frame(impute.MinDet(impute_meat))
meat_imputed <- cbind(meat_data[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
#### calculate the means for the replicates
meat_groups <- generate_categorical_table(meat_imputed$Group)
meat_numeric <- meat_imputed
meat_numeric$Sample_nr <- as.numeric(meat_numeric$Sample_nr)
meat_numeric$Group <- as.numeric(meat_numeric$Group)
# meat_by_sample <- calc_by_replicate(meat_numeric, meat_numeric$Sample_nr, mean)
meat_by_replicate <- calc_by_replicate(meat_numeric, meat_numeric$Biol_rep, mean)
meat_data <- paste_catecorical_variable(meat_by_replicate, 3, meat_groups)
colnames(meat_data)[1] <- "Bio_replicate"
meat_data$Sample_nr <- paste("sample", meat_data$Sample_nr, sep = "")
### graphical exploratory data analysis
# qqplot_by_factor(meat_data, "Group", out_path = plot_name)
# histogram_by_factor(meat_data, "Group", out_path = plot_name)
# boxplot_by_factor(meat_data, "Group", out_path = plot_name)
#
# parallel_plot(meat_data, meat_data$Group, out_path = plot_name)
# meat_spider <- calc_by_replicate(meat_data, meat_data$Group, mean)
# spider_chart(meat_spider, legend_lab = meat_spider$Group.1, out_path = plot_name)
### test for normality
meat_normality <- shapiro_by_factor(meat_data, meat_data$Group)
### test for correlation
meat_correlation <- cor(select_if(meat_data, is.numeric), method = "spearman")
matrix_heatmap(meat_correlation, title = "Correlation heatmap", interactive = FALSE)
### ratio heatmap
meat_sample_means <- calc_by_replicate(meat_data, factor = meat_data$Sample_nr, mean)
ratio_list <- list()
for(i in 1:nrow(meat_sample_means)){
buffer <- calculate_ratio_matrix(as.numeric(meat_sample_means[i, -1]), names_vector = 1:ncol(meat_sample_means[-1]))
list_name <- meat_sample_means$Group.1[i]
ratio_list[[list_name]] <- buffer
}
heatmap_list <- list()
for(i in 1:length(ratio_list)){
buffer <- matrix_heatmap(ratio_list, title = names(ratio_list)[i], interactive = FALSE)
list_name <- names(ratio_list)[i]
heatmap_list[[list_name]] <- buffer
}
lipid_ratio_heatmaps <- ggarrange(plotlist = heatmap_list,
ncol = 2,
nrow = 4,
align = "h",
widths = c(0.9, 0.9),
common.legend = TRUE,
legend = "right")
lipid_ratio_heatmaps <- annotate_figure(lipid_ratio_heatmaps,
top = text_grob("Lipid ratios per sample",
size = 16, family = "AvantGarde"))
ggsave(filename = paste(plot_name, "_ratio_heatmap.png", sep = ""),
plot = lipid_ratio_heatmaps, width = 8, height = 12)
### PCA
meat_pca <- PCA(select_if(meat_data, is.numeric), scale.unit = TRUE, graph = FALSE)
meat_eigenvalue <- get_eigenvalue(meat_pca)
scree_factoextra(meat_pca)
scree_base(select_if(meat_data, is.numeric))
biplot_ggplot2(meat_data, "Group", loadings = FALSE, ellipse = TRUE, scale = TRUE)
biplot_factoextra(meat_pca, meat_data$Group, ellipse = TRUE)
# loadings plots
fviz_pca_var(meat_pca, # factoextra
geom = c("point"),
col.var = "contrib",
gradient.cols = viridis(n = 3, direction = -1),
repel = TRUE)
plot_loadings(meat_pca, colour = TRUE, top_loadings = 10) # diy wth ggplot
# contribution to PCs
plot_contrib_to_pc(meat_pca)
fviz_contrib(meat_pca, choice = "var", axes = 1, top = 10,
fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3),
ggtheme = my_theme)
fviz_contrib(meat_pca, choice = "var", axes = 2, top = 10,
fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3),
ggtheme = my_theme,
linecolor = "black")
### Clustering
meat_clust <- data.frame(Group = meat_data$Group)
meat_clust <- cbind(meat_clust, select_if(meat_data, is.numeric))
rownames(meat_clust) <- meat_data$SID
hclust_performance_table(meat_clust)
hclust_performance_plot(meat_clust)
meat_dist <- dist(select_if(meat_clust, is.numeric), method = "manhattan")
meat_hclust <- hclust(meat_dist, method = "average")
hclust_dendrogram(meat_hclust,
labs = paste(meat_data$Sample_nr,
meat_clust$Group, sep = "-"))
# hclust_heatmap(meat_clust,
#                dist_method = "manhattan",
#                hclust_method = "average",
#                row_names = meat_clust$Group,
#                out_path = plot_name)
hclust_heatmap_interactive(meat_clust,
dist_method = "manhattan",
hclust_method = "average",
out_path = "/plots/meat")
### hypothesis testing & volcano plot
# kruskal-wallis
meat_kruskal <- kruskal_test_by_col(meat_data, "Group")
meat_kruskal$p_adj <- p.adjust(meat_kruskal$p_value, method = "fdr")
meat_significant_k <- subset(meat_kruskal, meat_kruskal$p_value <= 0.05)
# anova
meat_anova <- one_way_anova_by_col(meat_data, "Group")
meat_anova$p_adj <- p.adjust(meat_anova$p_value, method = "fdr")
meat_significant_a <- subset(meat_anova, meat_anova$p_value <= 0.05)
{ # meat vs fish volcano plot
meat_vs_fish <- subset(meat_data, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = t.test)
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish$p_values, method = "fdr")
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish,
meat_vs_fish$Group,
control_group = "fish",
test_group = "meat")
meat_fish_volcano <- data.frame(p_value = p_meat_vs_fish, adj_p_value = adj_meat_vs_fish, log2_foldchange = fc_meat_vs_fish)
meat_fish_volcano <- meat_fish_volcano[complete.cases(meat_fish_volcano),]
volcano_plot(meat_fish_volcano,
foldchange_col = meat_fish_volcano$log2_foldchange,
significance_col = meat_fish_volcano$adj_p_value,
foldchange = 1,
significance = 0.05,
out_path = plot_name)
}
{ # meat vs game volcano plot
meat_vs_game <- subset(meat_data, Group == "game" | Group == "meat")
meat_vs_game <- droplevels(meat_vs_game)
p_meat_vs_game <- one_sample_test_by_col(meat_vs_game, meat_vs_game$Group, method = t.test)
adj_meat_vs_game <- p.adjust(p_meat_vs_game$p_values, method = "fdr")
fc_meat_vs_game <- log2_foldchange(meat_vs_game,
meat_vs_game$Group,
control_group = "meat",
test_group = "game")
meat_game_volcano <- data.frame(p_value = p_meat_vs_game, adj_p_value = adj_meat_vs_game, log2_foldchange = fc_meat_vs_game)
meat_game_volcano <- meat_game_volcano[complete.cases(meat_game_volcano),]
volcano_plot(meat_game_volcano,
foldchange_col = meat_game_volcano$log2_foldchange,
significance_col = meat_game_volcano$adj_p_value,
foldchange = 1,
out_path = plot_name)
}
{ # game vs fish volcano plot
# game vs fish volcano plot
game_vs_fish <- subset(meat_data, Group == "fish" | Group == "game")
game_vs_fish <- droplevels(game_vs_fish)
p_game_vs_fish <- one_sample_test_by_col(game_vs_fish, game_vs_fish$Group, method = t.test)
adj_game_vs_fish <- p.adjust(p_game_vs_fish$p_values, method = "fdr")
fc_game_vs_fish <- log2_foldchange(game_vs_fish,
game_vs_fish$Group,
control_group = "fish",
test_group = "game")
volcano_df <- data.frame(p_value = p_game_vs_fish, adj_p_value = adj_game_vs_fish, log2_foldchange = fc_game_vs_fish)
volcano_df <- volcano_df[complete.cases(volcano_df),]
volcano_plot(volcano_df,
foldchange_col = volcano_df$log2_foldchange,
significance_col = volcano_df$adj_p_value,
foldchange = 1,
significance = 0.05,
title = "Fish vs. game",
out_path = plot_name)
}
