meat_clust <- data.frame(Group = meat_imputed$Group)
meat_clust <- cbind(meat_clust, select_if(meat_imputed, is.numeric))
rownames(meat_clust) <- meat_imputed$SID
hclust_performance_table(meat_clust)
hclust_performance_plot(meat_clust)
meat_dist <- dist(select_if(meat_clust, is.numeric), method = "manhattan")
meat_hclust <- hclust(meat_dist, method = "average")
hclust_dendrogram(meat_hclust, labs = meat_clust$Group)
hclust_heatmap(meat_clust, dist_method = "manhattan", hclust_method = "average", row_names = meat_clust$Group)
hclust_heatmap_interactive(meat_clust, dist_method = "manhattan", hclust_method = "average")
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
ttest_by_column(meat_vs_fish, meat_vs_fish$Group)
ttest_by_column(my_iris, my_iris$Species)
#'
#' @description `p_values_by_column` takes a data frame and a grouping vector and returns a data frame with the p-values of a given method.
#' @details This function takes a data frame ans a grouping vector and performs a given hypothesis test on all numeric variables. The results are returned in a new data frame.
#' @param input_df data frame. Contains at least one numeric variable.
#' @param group_vector vector. Vector containing the groups to be compared. group_vector = input_df$group (or other vector of length nrow(input_df))
#' @param alternative string. Specifies the alternative hypothesis. c("two.sided" (default), "greater", "less")
#' @param confidence_level numeric. Confidence level of the interval. Default = 0.95
#' @example
#' my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
#' ttest_by_column(my_iris, my_iris$Species)
ttest_by_column <- function(input_df,
group_vector,
alternative = "two.sided",
method = t.test,
confidence_level = 0.95){
p_values <- apply(select_if(input_df, is.numeric), 2,
function(x) method(x ~ group_vector,
alternative = alternative,
conf.level = confidence_level)$p.value)
as.data.frame(p_values)
}
ttest_by_column(my_iris, my_iris$Species)
### load packages
library(dplyr) # select part of data
library(stringr) # count separators
library(data.table) # transpose data frame
library(impute)
library(imputeLCMD)
library(ggplot2)#, # plots
library(tibble) # data frame manipulation
library(viridis) # colorblind save color schemes
library(GGally) # paralell plot
library(fmsb) # spider chart
library(scales) # scale opacity of filling (alpha)
library(ggrepel)
library(factoextra)
library(ggfortify) # biplot with ggplot
library(heatmaply) # interactive heatmap
library(gplots) # heatmap
library(plotly) # interactive heatmap
# library(psych) # for correlation plot
# library(gridExtra)
# library(devtools)
# library(dendextend)
# library(limma) # hypothesis testing
source("lipidome_comparison_dataTransformaions.R")
source("lipidome_comparison_EDA.R")
source("lipidome_comparison_pca.R")
source("lipidome_comparison_clustering.R")
source("lipidome_comparison_hypothesis_testing.R")
# set ggplot theme
my_theme <- theme_set(
theme_minimal() +
theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
axis.text.x = element_text(size = 8, colour = "grey40", family="AvantGarde"),
axis.text.y = element_text(size = 8, colour = "grey40", family="AvantGarde"),
# axis.title = element_text(size = 10, colour = "grey40", family="AvantGarde"),
axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
legend.text = element_text(size = 8, colour = "grey40", family="AvantGarde"),
legend.title = element_text(size = 10, colour = "grey40", family="AvantGarde"))
)
## set variables
working_directory <- "/home/lisa/FH/Masterarbeit/LipidomeComparison"
setwd(working_directory)
test_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/Probe-Datensatz_lisa.csv"
meat_data_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/meat_fish_final_raw.csv"
plot_path <- paste(working_directory, "/plots", sep = "")
plot_name <- paste(plot_path, "/meat_data", sep = "")
## meat data
### data processing
meat_data <- read.csv(meat_data_path, sep = ",", dec = ".", header = TRUE)
meat_data <- subset(meat_data, select = c(Compound, Type, Filename, Status, Group, Area))
meat_data <- subset(meat_data, Status == "Processed")
meat_data[meat_data==''] <- NA
meat_data[meat_data=='N/F'] <- NA
meat_data$Area <- as.numeric(meat_data$Area)
meat_target <- subset(meat_data, Type == "Target Compound")
meat_standard <- subset(meat_data, Type == "Internal Standard")
meat_target <- flip_df(meat_target)
meat_target <- subset(meat_target, !is.na(Group))
meat_target$SID <- sub(".*probe","sample", meat_target$SID)
meat_target$SID <- sub("\\.*pos2","2", meat_target$SID)
meat_target$SID <- sub("\\.*pos","1", meat_target$SID)
meat_AS <- meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE]
meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] <- sub(".*sample","AS_sample", meat_AS)
meat_N <- meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE]
meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] <- sub(".*sample","N_sample", meat_N)
meat_target$SID <- str_remove(meat_target$SID, "_AS")
meta_info <- read.table(text = meat_target$SID, sep = "_")
colnames(meta_info) <- c("Treatment", "Sample_nr", "Biol_rep", "Tech_rep")
meta_info$Biol_rep <- paste(meta_info$Sample_nr, meta_info$Biol_rep, sep = "_")
meta_info$Tech_rep <- paste(meta_info$Biol_rep, meta_info$Tech_rep, sep = "_")
meat_target <- cbind(meat_target$SID, meta_info, meat_target[, -1])
meat_target <- droplevels(meat_target)
levels(meat_target$Group)[levels(meat_target$Group) == "fleisch"] <- "meat"
levels(meat_target$Group)[levels(meat_target$Group) == "wild"] <- "game"
levels(meat_target$Group)[levels(meat_target$Group) == "FISCH"] <- "fish"
colnames(meat_target) <- c("SID", colnames(meat_target[-1]))
meat_N <- subset(meat_target, Treatment == "N")
meat_AS <- subset(meat_target, Treatment == "AS")
levels(meat_N$Group)
## Exploratory data analysis
### impute missing values
#### remove columns where all values are missing
impute_meat <- meat_N[, which(colMeans(!is.na(meat_N)) > 0.8)]
impute_meat <- as.matrix(select_if(impute_meat, is.numeric))
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat)
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
#### calculate the means for the replicates
{
meat_groups <- generate_categorical_table(meat_imputed$Group)
meat_treatment <- generate_categorical_table(meat_imputed$Treatment)
meat_numeric <- meat_imputed
meat_numeric$Group <- as.numeric(meat_numeric$Group)
meat_biol <- calc_by_replicate(meat_numeric, meat_numeric$Sample_nr, mean)
meat_tech <- calc_by_replicate(meat_numeric, meat_numeric$Biol_rep, mean)
nmb <- paste_catecorical_variable(meat_biol, 2, meat_groups)
nmt <- paste_catecorical_variable(meat_tech, 2, meat_groups)
}
### graphical exploratory data analysis
# qqplot_by_factor(meat_imputed, "Group", out_path = plot_name)
# histogram_by_factor(meat_imputed, "Group", out_path = plot_name)
# boxplot_by_factor(meat_imputed, "Group", out_path = plot_name)
#
# parallel_plot(meat_imputed, meat_imputed$Group, out_path = plot_name)
# meat_spider <- calc_by_replicate(meat_imputed, meat_imputed$Group, mean)
# spider_chart(meat_spider, legend_lab = meat_spider$Group.1, out_path = plot_name)
### test for normality
meat_normality <- shapiro_by_factor(meat_imputed, meat_imputed$Group)
### test for correlation
meat_correlation <- cor(select_if(meat_imputed, is.numeric), method = "spearman")
correlation_heatmap(meat_imputed, interactive = TRUE, out_path = plot_name)
### PCA
meat_pca <- prcomp(select_if(meat_imputed, is.numeric))
meat_pca_var <- meat_pca$sdev ^ 2
prop_var_meat <- round(meat_pca_var / sum(meat_pca_var) * 100, 2)
cum_prop_var_meat <- cumsum(prop_var_meat * 100)
proportion_of_variance_table <- data.frame(Proportion_of_variance = prop_var_meat, Cummulative_proportion_of_variance = cum_prop_var_meat)
scree_base(meat_pca)
scree_factoextra(meat_pca)
biplot_ggplot2(meat_imputed, "Group", loadings = FALSE, ellipse = TRUE)
biplot_factoextra(meat_pca, meat_imputed$Group, ellipse = TRUE)
### Clustering
meat_clust <- data.frame(Group = meat_imputed$Group)
meat_clust <- cbind(meat_clust, select_if(meat_imputed, is.numeric))
rownames(meat_clust) <- meat_imputed$SID
hclust_performance_table(meat_clust)
hclust_performance_plot(meat_clust)
meat_dist <- dist(select_if(meat_clust, is.numeric), method = "manhattan")
meat_hclust <- hclust(meat_dist, method = "average")
hclust_dendrogram(meat_hclust, labs = meat_clust$Group)
hclust_heatmap(meat_clust, dist_method = "manhattan", hclust_method = "average", row_names = meat_clust$Group)
hclust_heatmap_interactive(meat_clust, dist_method = "manhattan", hclust_method = "average")
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
ttest_by_column(meat_vs_fish, meat_vs_fish$Group)
ttest_by_column(my_iris, my_iris$Species)
my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
ttest_by_column(my_iris, my_iris$Species)
ttest_by_column(my_iris, my_iris$Species, method = wilcox.test)
#' @description `p_values_by_column` takes a data frame and a grouping vector and returns a data frame with the p-values of a given method.
#' @details This function takes a data frame ans a grouping vector and performs a given hypothesis test on all numeric variables. The results are returned in a new data frame.
#' @param input_df data frame. Contains at least one numeric variable.
#' @param group_vector vector. Vector containing the groups to be compared. group_vector = input_df$group (or other vector of length nrow(input_df))
#' @param alternative string. Specifies the alternative hypothesis. c("two.sided" (default), "greater", "less")
#' @param confidence_level numeric. Confidence level of the interval. Default = 0.95
#' @example
#' my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
#' ttest_by_column(my_iris, my_iris$Species)
#' ttest_by_column(my_iris, my_iris$Species, method = wilcox.test)
ttest_by_column <- function(input_df,
group_vector,
alternative = "two.sided",
method = wilcox.test,
confidence_level = 0.95){
p_values <- apply(select_if(input_df, is.numeric), 2,
function(x) method(x ~ group_vector,
alternative = alternative,
conf.level = confidence_level)$p.value)
as.data.frame(p_values)
}
ttest_by_column(my_iris, my_iris$Species)
ttest_by_column(my_iris, my_iris$Species, method = t.test)
ttest_by_column(my_iris, my_iris$Species, method = wilcox.test)
#' @description `p_values_by_column` takes a data frame and a grouping vector and returns a data frame with the p-values of a given method.
#' @details This function takes a data frame ans a grouping vector and performs a given hypothesis test on all numeric variables. The results are returned in a new data frame.
#' @param input_df data frame. Contains at least one numeric variable.
#' @param group_vector vector. Vector containing the groups to be compared. group_vector = input_df$group (or other vector of length nrow(input_df))
#' @param alternative string. Specifies the alternative hypothesis. c("two.sided" (default), "greater", "less")
#' @param confidence_level numeric. Confidence level of the interval. Default = 0.95
#' @example
#' my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
#' ttest_by_column(my_iris, my_iris$Species)
#' ttest_by_column(my_iris, my_iris$Species, method = wilcox.test)
ttest_by_column <- function(input_df,
group_vector,
alternative = "two.sided",
method = t.test,
confidence_level = 0.95){
p_values <- apply(select_if(input_df, is.numeric), 2,
function(x) method(x ~ group_vector,
alternative = alternative,
conf.level = confidence_level)$p.value)
as.data.frame(p_values)
}
ttest_by_column(my_iris, my_iris$Species, method = wilcox.test)
ttest_by_column(my_iris, my_iris$Species)
one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
## set ggplot theme
my_theme <- theme_set(
theme_minimal() +
theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
axis.text.x = element_text(size = 8, colour = "grey40", family="AvantGarde"),
axis.text.y = element_text(size = 8, colour = "grey40", family="AvantGarde"),
# axis.title = element_text(size = 10, colour = "grey40", family="AvantGarde"),
axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
legend.text = element_text(size = 8, colour = "grey40", family="AvantGarde"),
legend.title = element_text(size = 10, colour = "grey40", family="AvantGarde"))
)
#' Calculate p-values by column
#'
#' @description `p_values_by_column` takes a data frame and a grouping vector and returns a data frame with the p-values of a given method.
#' @details This function takes a data frame ans a grouping vector and performs a given hypothesis test on all numeric variables. The results are returned in a new data frame.
#' @param input_df data frame. Contains at least one numeric variable.
#' @param group_vector vector. Vector containing the groups to be compared. group_vector = input_df$group (or other vector of length nrow(input_df))
#' @param alternative string. Specifies the alternative hypothesis. c("two.sided" (default), "greater", "less")
#' @param method function. Options: t.test (default), wilcox.test
#' @param confidence_level numeric. Confidence level of the interval. Default = 0.95
#' @example
#' my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
#' one_sample_test_by_col(my_iris, my_iris$Species)
#' one_sample_test_by_col(my_iris, my_iris$Species, method = wilcox.test)
one_sample_test_by_col <- function(input_df,
group_vector,
alternative = "two.sided",
method = t.test,
confidence_level = 0.95){
p_values <- apply(select_if(input_df, is.numeric), 2,
function(x) method(x ~ group_vector,
alternative = alternative,
conf.level = confidence_level)$p.value)
as.data.frame(p_values)
}
#' Calculate log2 foldchange
#'
#' @description `log2_foldchange` calculates the log2 foldchange for two groups of a given data frame.
#' @details This function takes a data frame and a grouping vector and calculates the log2 foldchange between two groups.
#' The results are returned in a new data frame.
#' @param input_df data frame. Contains at least one numeric variable.
#' @param group_vector vector. Vctor containing the grouping variabe. group_vector = input_df$group (or any vector of length nrow(input_df))
#' @example
#' my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
#' log2_foldchange(my_iris, my_iris$Species)
log2_foldchange <- function(input_df,
group_vector){
log2_df <- log2(select_if(input_df, is.numeric))
log2_df$group <- group_vector
means <- aggregate(select_if(log2_df, is.numeric), by = list(log2_df$group), FUN = mean)
rownames(means) <- means$Group.1
means <- as.data.frame(select_if(means, is.numeric))
log2_foldchange <- vector()
for(i in 1:ncol(means)){
log2_foldchange[i] <- means[1, i] - means[2, i]
}
out_df <- as.data.frame(log2_foldchange)
rownames(out_df) <- colnames(select_if(input_df, is.numeric))
out_df
}
#' Volcano plot
#'
#' @description `volcano_plot` prints a volcano plot using a data frame containing p-values and foldchanges
#' @details This function takes a data frame with columns for p-values and (log2)foldchanges and returns a dotplot resembelling a volcano plot.
#' It uses the given significance and foldchange threshods to mark significantly up- and down-regulated elements by color and by displaying
#' threshold lines.
#' @param input_df data frame.
#' @param foldchange_col vector. Column of input_df containing the foldchange values. Format: input_df$foldchange_col
#' @param significance_col vector. Column of input_df containing the p-values. Format: input_df$significance_col
#' @param significance numeric. Value for the significance threshold. Default = 0.05.
#' @param foldchange numeric. Vaue for the foldchange threshold. Default = #todo
#' @param title string. Main title. Default = "Volcano plot"
#' @param x_lab string. x-axix title. Default = "log2Fold"
#' @param y_lab string. y-axis title- Default = "-log10(p-value)"
#' @param labels vector of length nrow(volcano_df). Default = "none". If lables is set, points above the threshold are labelled.
#' @param out_path string. Path to save volcano plot do png. Default = "none".
#' If "none", the plot is either printed or saved to a variabe.
#' @example
#' set.seed(100)
#' fold_changes <- c(rnorm(2000, 0, 2))
#' pvalues <- runif(n=2000, min=1e-50, max=.1)
#' volcano_test <- as.data.frame(cbind(fold_changes, pvalues))
#' volcano_plot(volcano_test,
#'              foldchange_col = volcano_test$fold_changes,
#'              significance_col = volcano_test$pvalues, foldchange = 1)
#' volcano_plot(volcano_test,
#'              foldchange_col = volcano_test$fold_changes,
#'              significance_col = volcano_test$pvalues,
#'              foldchange = 1,
#'              labels =c(1:nrow(volcano_test)))
#' \dontrun
#' {dir.create(paste(getwd(), "/examples", sep = ""), showWarnings = FALSE)
#' dir <- paste(getwd(), "/examples/vp", sep = "")
#' volcano_plot(volcano_test,
#'              foldchange_col = volcano_test$fold_changes,
#'              significance_col = volcano_test$pvalues,
#'              foldchange = 1, significance = 0.01,
#'              out_path = dir)}
volcano_plot <- function(volcano_df,
foldchange_col, significance_col,
significance = 0.05,
foldchange, #todo = 0.05
title = "Volcano plot",
x_lab = "log2Fold", y_lab = "-log10(p-value)",
labels = vector(),
out_path = "none"){
is_significant <- significance_col < significance
threshold <- vector()
for(i in 1:length(is_significant)){
if(is_significant[i] == TRUE && foldchange_col[i] < -1*foldchange){
buffer <- "down"
}
else if(is_significant[i] == TRUE && foldchange_col[i] > foldchange){
buffer <- "up"
}
else{
buffer <- "not_sig"
}
threshold <- c(threshold, buffer)
}
volcano_df <- cbind(volcano_df, threshold)
limits <- max(-1*min(foldchange_col), max(foldchange_col))
mycolors <- viridis(n = 2, begin = 0, end = 0.9)
volcano <- ggplot(data = volcano_df,
aes(x = foldchange_col, y = -1*log10(significance_col))) +
geom_point(aes(color = as.factor(threshold)), shape = 20) +
geom_hline(yintercept = -1*log10(significance),
linetype = "dashed",
colour = "grey40") +
geom_vline(xintercept = -1*foldchange,
linetype = "dashed",
colour = "grey40") +
geom_vline(xintercept = foldchange,
linetype = "dashed",
colour = "grey40") +
labs(title = title) +
xlab(x_lab) + ylab(y_lab) +
scale_x_continuous(limits = c(-1*limits, limits)) +
scale_color_manual(name = "Threshold",
values = c("up" = mycolors[1], "down" = mycolors[2], "not_sig" = "grey"),
labels = c("Down-regulated", "Not significant FC", "Up-regulated")) +
theme(legend.position = "right")
if (length(labels) != 0){
volcano <- volcano + geom_text_repel(aes(label=ifelse(threshold != "not_sig", as.character(labels),'')),
hjust=0, vjust=0,
size = 3)
}
if(out_path != "none"){
print(paste("Saving plot to ", out_path, "_volcano.png", sep = ""))
ggsave(paste(out_path, "_volcano.png", sep = ""),
plot = volcano)
}
volcano
}
one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
my_iris <- subset(x = iris, Species == "setosa" | Species == "versicolor")
log2_foldchange(my_iris, my_iris$Species)
log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
meat_vs_fish
log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
fc_meat_vs_fish
log2_df <- log2(select_if(fc_meat_vs_fish, is.numeric))
log2(meat_vs_fish)
log2(select_if(fc_meat_vs_fish, is.numeric))
### impute missing values
#### remove columns where all values are missing
impute_meat <- meat_N[, which(colMeans(!is.na(meat_N)) > 0.8)]
impute_meat <- as.matrix(select_if(impute_meat, is.numeric))
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat)
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
is.negative(meat_imputed)
meat_imputed
meat_N
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat)
meat_QRILC
meat_imputed
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat, tune.sigma = 2)
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
log2(meat_vs_fish)
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat, tune.sigma = 0)
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat, tune.sigma = 10)
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
warnings()
#### perform missing data imputation
meat_QRILC = impute.QRILC(impute_meat, tune.sigma = 1)
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
#### calculate the means for the replicates
{
meat_groups <- generate_categorical_table(meat_imputed$Group)
meat_treatment <- generate_categorical_table(meat_imputed$Treatment)
meat_numeric <- meat_imputed
meat_numeric$Group <- as.numeric(meat_numeric$Group)
meat_biol <- calc_by_replicate(meat_numeric, meat_numeric$Sample_nr, mean)
meat_tech <- calc_by_replicate(meat_numeric, meat_numeric$Biol_rep, mean)
nmb <- paste_catecorical_variable(meat_biol, 2, meat_groups)
nmt <- paste_catecorical_variable(meat_tech, 2, meat_groups)
}
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
log2(meat_vs_fish)
fc_meat_vs_fish
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish, method = "FDR")
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish, method = "fdr")
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish, method = "fdr")
adj_meat_vs_fish <- apply(p_meat_vs_fish, 2,
function(x) p.adjust(x ~ group_vector,
method = "fdr"))
p_meat_vs_fish
adj_meat_vs_fish <- apply(p_meat_vs_fish, method = "fdr")
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish, method = "fdr")
typeof(p_meat_vs_fish)
adj_meat_vs_fish <- p.adjust(as.vector(p_meat_vs_fish), method = "fdr")
adj_meat_vs_fish <- p.adjust(as.numeric(p_meat_vs_fish), method = "fdr")
as.numeric(p_meat_vs_fish)
as.vector(p_meat_vs_fish)
adj_meat_vs_fish <- p.adjust(p_meat_vs_fish$p_values, method = "fdr")
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group)
fc_meat_vs_fish <- log2_foldchange(meat_vs_fish, meat_vs_fish$Group, warnings = FALSE)
meat_volcano <- data.frame(p_value = p_meat_vs_fish, adj_p_value = adj_meat_vs_fish, log2_foldchange = fc_meat_vs_fish)
meat_volcano
volcano_plot(mea,
foldchange_col = meat_volcano$log2_foldchange,
significance_col = meat_volcano$p_values,
foldchange = 2,
significance = 0.5)
meat_volcano <- data.frame(p_value = p_meat_vs_fish, adj_p_value = adj_meat_vs_fish, log2_foldchange = fc_meat_vs_fish)
meat_volcano <-  meat_volcano[complete.cases(meat_volcano), ]
volcano_plot(mea,
foldchange_col = meat_volcano$log2_foldchange,
significance_col = meat_volcano$p_values,
foldchange = 2,
significance = 0.5)
volcano_plot(meat_volcano,
foldchange_col = meat_volcano$log2_foldchange,
significance_col = meat_volcano$p_values,
foldchange = 2,
significance = 0.5)
meat_zero <- impute.ZERO(impute_meat)
meat_imputed <- as.data.frame(meat_zero)
meat_imputed
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
meat_zero <- impute.ZERO(impute_meat)
meat_imputed <- as.data.frame(meat_zero)
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
### hypothesis testing & volcano plot
meat_vs_fish <- subset(meat_imputed, Group == "fish" | Group == "meat")
meat_vs_fish <- droplevels(meat_vs_fish)
p_meat_vs_fish <- one_sample_test_by_col(meat_vs_fish, meat_vs_fish$Group, method = wilcox.test)
