#### R script with functions for lipidome comparison ####

### Data handelling ###

#' Transpose data frame and save row- and column names correctly.
#' 
#' @description 
#' `pretty_transpose` transposes a data frame to a new data frame
#' @details 
#' This function takes a data frame, transposes it and sets the former first column as the column names. 
#' Row names are automatically generated by the data.table::transpose() function. 
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(cbind(c("ID", "a", "b", "c", "d"), c("z", 1, 2, 3, 4), c("x", 5, 6, 7, 8)))
#' pretty_transpose(df)
pretty_transpose <- function(input_df){
  t_input_df <- data.table::transpose(as.data.table(input_df), make.names = 1)
  t_input_df <- as.data.frame(t_input_df)
  row.names(t_input_df) <- colnames(input_df[-1])
  t_input_df
}

#' Takes a data frame with specific rownames and extracts meta data from it
#' 
#' @description 
#' `SID_to_metadata` takes a data frame with rownames in the form of 
#' <experiment_treatment_biol.rep.nr_tech.rep.nr> 
#' and extracts meta data
#' @details 
#' This function takes the information saved in sample IDs of the form 
#' <experiment_treatment_biol.rep.nr_tech.rep.nr> and saves each 
#' part of the sample ID as a column of character strings. 
#' If one part is missing, the column is filled with NAs. 
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(rbind(c(1, 2, 3, 4), c(5, 6, 7, 8)))
#' row.names(df) <- c("Ex1_Tr1_1_1", "Ex1_Tr1_1_2")
#' colnames(df) <- c("a", "b", "c", "d")
#' ndf <- SID_to_metadata(df); ndf
SID_to_metadata <- function(input_df){
  n_sep <- mean(stringr::str_count(row.names(input_df), "_"))
  meta_info <- read.table(text = row.names(input_df), sep = "_")
  
  if(n_sep == 2){
    biol_rep <- paste(meta_info$V1, meta_info$V2, sep = "_")
    treatment <- meta_info$V1
    input_df <- tibble::add_column(input_df, biol_replicate = biol_rep, .before = 1)
    input_df <- tibble::add_column(input_df, treatment = treatment, .before = 1)
    input_df <- tibble::add_column(input_df, experiment = NA, .before = 1)
  } else if(n_sep == 3){
    biol_rep <- paste(meta_info$V1, meta_info$V2, meta_info$V3, sep = "_")
    treatment <- meta_info$V2
    experiment <- meta_info$V1
    input_df <- tibble::add_column(input_df, biol_replicate = biol_rep, .before = 1)
    input_df <- tibble::add_column(input_df, treatment = treatment, .before = 1)
    input_df <- tibble::add_column(input_df, experiment = experiment, .before = 1)
  } else{
    print("Wrong format")
  }
}

#' Transform all columns with caracters of a data frame to factor
#' 
#' @description 
#' `character_to_factor` takes a data frame with character strings and numerics 
#' and transforms all columns with characters only to factor columns
#' @details
#' All the columns of a data frame that only have character strings in them
#' are transformed to factor columns.
#' @param input_df a data frame with character strings and numerics
#' @examples 
#' df <- as.data.frame(rbind(c("Ex1", "TR1", 1, 2, 3, 4), c("Ex1", "Tr2", 5, 6, 7, 8)))
#' row.names(df) <- c("1", "2")
#' colnames(df) <- c("Ex", "Tr", "a", "b", "c", "d")
#' character_to_factor(df)
character_to_factor <- function(input_df){
  for(i in 1:ncol(input_df)){
    if (!is.numeric(input_df[,i])){
      input_df[,i] <- factor(input_df[,i])
    }
  }
  new_df <- input_df
}

### Exploratory data analysis  ###

#' Aggregate function results by factor
#' 
#' @description 
#' `calc_by_replicate` takes a data frame calculates the results of a fuction grouped by a factor
#' @details 
#' `calc_by_replicate` takes a data frame calculates the results of a fuction grouped by a factor
#' @param input_df a data frame with at least one factor column
#' @param factor a string with the column name to group by
#' @param funct a generic R function, that takes only one argument (e.g. mean(), summary(), etc.)
#' @examples 
#' calc_by_replicate(iris, "Species", mean)
calc_by_replicate <- function(input_df, factor, funct){ 
  as.data.frame(
    aggregate(dplyr::select_if(input_df, is.numeric), 
              by=list(input_df[[factor]]), 
              FUN=funct)
  )
}

### Graphical exploratory data analysis 
#' Print one qqplot for each variable and group
#' 
#' @description `qqplot_by_factor` takes a data frame and prints a qq-plot for each group and varible
#' @details Take a data frame and prints a qq-plot for each group and varible. 
#' @param input_df a data frame with at least one factor column
#' @param factor a string with the column name to group by
#' @param out_path optional string. 
#' If out path is given, the generated plots are saved to a pdf document with the given name. 
#' @example 
#' qqplot_by_factor(iris, "Species")
#' dir <- paste(getwd(), "/plots/iris", sep = "")
#' qqplot_by_factor(iris, "Species", dir)
qqplot_by_factor <- function(input_df, factor, out_path = 1){
  levels <- levels(input_df[[factor]]) 
  numeric_df <- dplyr::select_if(input_df, is.numeric)
  
  if(out_path == 1){
    for (i in 1:length(levels)){ 
      # pdf(paste(out_path, "_qqplot_", levels[i], ".pdf", sep = ""))
      par(mfrow=c(3,3))
      for (j in 1:ncol(numeric_df)){
        col_name <- colnames(numeric_df)[j]
        qqnorm(numeric_df[,j][input_df[[factor]] == levels[i]],
               main = paste(col_name, levels[i], sep = " "),
               cex.main = 0.8)
        qqline(numeric_df[,j][input_df[[factor]] == levels[i]])}
      # dev.off()
      }
  }
  else{
    for (i in 1:length(levels)){ 
      pdf(paste(out_path, "_qqplot_", levels[i], ".pdf", sep = ""))
      par(mfrow=c(3,3))
      for (j in 1:ncol(numeric_df)){
        col_name <- colnames(numeric_df)[j]
        qqnorm(numeric_df[,j][input_df[[factor]] == levels[i]],
               main = paste(col_name, levels[i], sep = " "),
               cex.main = 0.8)
        qqline(numeric_df[,j][input_df[[factor]] == levels[i]])}
      dev.off()
    }
  }
}

# if(out_path = ""){
  #   
  # }
  # else{
  #   for (i in 1:length(levels)){ 
  #     # pdf(paste(out_path, "_qqplot_", levels[i], ".pdf", sep = "")) 
  #     par(mfrow=c(3,3))
  #     for (j in 1:ncol(numeric_df)){
  #       col_name <- colnames(numeric_df)[j]
  #       qqnorm(numeric_df[,j][input_df[[factor]] == levels[i]],
  #              main = paste(col_name, levels[i], sep = " "),
  #              cex.main = 0.8)
  #       qqline(numeric_df[,j][input_df[[factor]] == levels[i]])}
  #     # dev.off()
  #   }
  # }

  
  
  
  
    


## histogram by factor
# print one pdf document with histograms and density lines per factor for all lipids
histogram_by_factor <- function(input_df, by_factor, out_path){
  levels <- levels(input_df[[by_factor]])
  for (i in 1:length(levels)){
    # pdf(paste(plot_name, "_histogram_", levels[i], ".pdf", sep = ""))
    par(mfrow=c(3,3))
    for (j in 4:ncol(input_df[,1: ncol(input_df)])){
      col_name <- colnames(input_df)[j]
      
      hist(input_df[,j][input_df[[by_factor]] == levels[i]],
           main = col_name,
           cex.main = 0.8,
           xlab = NULL)
      lines(density(input_df[,j][input_df[[by_factor]] == levels[i]]))
      lines(density(input_df[,j][input_df[[by_factor]] == levels[i]], adjust = 1.5), lty = 2)
    }
    # dev.off()
  }
}

## boxplot by factor
boxplot_by_factor <- function(input_df, by_factor, out_path){ 
  # pdf(paste(plot_name, "_boxplot", ".pdf", sep = ""))
  par(mfrow=c(3,3))
    for (i in 4:ncol(input_df[,1: ncol(input_df)])){
      col_name <- colnames(input_df)[i]
      boxplot(input_df[,i] ~ input_df[[by_factor]], 
              main = col_name,
              cex.main = 0.8,
              xlab = NULL, 
              ylab = NULL)}
  # dev.off()
}

## shapiro-wilk by factor
shapiro_by_factor <- function(input_df, by_factor){
  
  shapiro_statistic <- aggregate(dplyr::select_if(input_df, is.numeric), 
                                 by = list(input_df[[by_factor]]),
                                 FUN = function(x) {y <- shapiro.test(x); c(y$statistic)})
  
  shapiro_statistic <- tibble::add_column(shapiro_statistic, 
                                          value = "W", 
                                          .before = 1)
  
  shapiro_pvalue <- aggregate(dplyr::select_if(input_df, is.numeric), 
                              by = list(input_df[[by_factor]]),
                              FUN = function(x) {y <- shapiro.test(x); c(y$p.value)})
  
  shapiro_pvalue <- tibble::add_column(shapiro_pvalue, 
                                       value = "p-Value", 
                                       .before = 1)
  
  shapiro_all <- rbind(shapiro_statistic, shapiro_pvalue)
  shapiro_all[order(shapiro_all[,2]), ]
}

## test for correlation
correlation_plot <- function(input_df, method){
  # pdf(paste(plot_name, "_correlations", ".pdf", sep = ""))
  panel.cor <- function(x, y){
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r <- round(cor(x, y, use = "pairwise.complete.obs", method = method), digits=2)
    txt <- paste0("R = ", r)
    text(0.5, 0.5, txt, cex = 1.5)
  }
  
  mypanel <- function(x, y){
    points(x, y, pch = 20)
  }
  
  pairs(dplyr::select_if(input_df, is.numeric),
        lower.panel = mypanel,
        upper.panel = panel.cor)
  # dev.off()
} # max 10 variables

## parallel coordinates plot 
parallel_plot <- function(input_df,  factor, out_path, 
                          titles = c("Paralell Plot", "", ""), 
                          scale = "center"){
  # # pdf(paste(plot_name, "_ParallelPlot", ".pdf", sep = ""))
  par(mfrow=c(1,1))
  
  parallel_title <- titles[[1]]
  x_axis_title <- titles[[2]]
  y_axis_title <- titles[[3]]
  x_labels <- substring(colnames(input_df[4:ncol(input_df)]), first = 1, last = 6)
  y_labels <- NULL
  
  # Plot
  ggparcoord(input_df,
             columns = 4:ncol(input_df),
             groupColumn = 2,
             showPoints = TRUE, 
             scale="center", # "center" is default
             alphaLines = 0.5)  +
    ggtitle(parallel_title) +
    xlab(x_axis_title) +
    ylab(y_axis_title) +
    scale_color_viridis(discrete=TRUE) +
    scale_x_discrete(breaks = colnames(input_df[4:ncol(input_df)]),
                      labels = x_labels) + 
    geom_point(shape = 20, size = 0.5) +
    my_theme
  # # dev.off()
}

## spider chart (= radar chart, network plot, etc.)
spider_chart <- function(minimized_df, title="Spider chart", out_path){ # todo get labels ot of the plot
  ## input_df <= 10 columns 
  ## minimized_df = dataframe with only one row per group (i.e. calculate means)
  
  # pdf(paste(plot_name, "_ParallelPlot", ".pdf", sep = ""))
  spider_legend <- row.names(minimized_df) # set new row names 
  spider_data <- dplyr::select_if(minimized_df, is.numeric) # remove column with rownames
  spider_labels <- substring(colnames(spider_data), first = 1, last = 6) # set max. label length to 10 characters

  spider_min <- floor(min(spider_data))
  spider_max <- ceiling(max(spider_data))
  spider_data <- as.data.frame(select_if(spider_data, is.numeric))

  # add max and min to the dataframe to plot the grid
  spider_data <- rbind(spider_min, spider_max, spider_data)

  ## set colors
  colors_border = as.vector(viridis(n = nrow(minimized_df), option = "viridis"))
  colors_in = alpha(colors_border, alpha = 0.1)

  ## radar chart
  radarchart(spider_data,
             axistype=0,
             #custom polygon
             pcol=colors_border,
             pfcol=colors_in,
             plwd=4,
             plty=1,
             # custom grid
             cglcol="grey",
             cglty=1,
             axislabcol="grey",
             cglwd=0.8,
             # custom labels
             vlcex=0.6, 
             centerzero = FALSE
  )
  
  title(main = title, cex.main = 0.9, font.main = 1)

  ## Add a legend
  legend(x=-2, 
         y=1.1, 
         legend = rownames(spider_data[-(1:2),]), 
         bty = "n", 
         pch=20, 
         col=colors_border, 
         text.col = "black", 
         cex=0.7, pt.cex=1.3)
  # dev.off()
}

### Principal component analysis

## scree plot with factoextra
scree_factoextra <- function(prcomp_element){
  factoextra::fviz_eig(prcomp_element, 
                       barfill = viridis(n = 2)[2], 
                       barcolor = viridis(n = 2)[2], 
                       linecolor = "grey40") +
    # scale_shape_manual(values = rep(20, nlevels(wd$treatment), size = 1)) +
    my_theme # sets general apperance, label size and justification
}
## biplot with factorextra
biplot_factoextra <- function(prcomp_element, groups, ellipse = TRUE){
  factoextra::fviz_pca_biplot(prcomp_element, 
                              ## color by group
                              habillage = groups, # a vector of groups by whicht to color
                              ## labels
                              label = "var", 
                              labelsize = 2,
                              repel = TRUE, # labels do not overlap
                              col.var = "grey40",
                              ## ellipses
                              addEllipses = ellipse, 
                              ellipse.type = "confidence",
                              ## legend
                              legend.title = "Groups"
  ) +
    scale_shape_manual(values = rep(20, nlevels(wd$treatment), size = 1)) +
    scale_color_viridis(discrete = TRUE) + 
    scale_fill_viridis(discrete = TRUE) +
    my_theme
}


## scree ggplot2
scree_base <- function(prcomp_element){
# variance explained by each pc
var_pca <- prcomp_element$sdev ^ 2
prop_of_variance <- var_pca / sum(var_pca)

par(mfrow=c(1,2))
plot(prop_of_variance, # scree plot to decide which PCs are used
     main = "", xlab ="", ylab ="",
     ylim=c(0 ,1),
     type = "b")
title( main = "Scree plot", cex.main = 0.9, font.main = 1, 
       cex.lab = 0.8, 
       xlab =" Principal Component ", 
       ylab =" Proportion of Variance Explained "
       )

plot(cumsum(prop_of_variance ), # scree plot to decide which PCs are used
     main = "", xlab ="", ylab ="",
     ylim=c(0 ,1),
     type="b")
title( main = "Cummulative scree plot", cex.main = 0.9, font.main = 1, 
       cex.lab = 0.8, 
       xlab ="Principal Component",
       ylab ="Cumulative Proportion of Variance Explained")

}


## biplot with ggplot2
biplot_ggplot2 <- function(input_df, groups){
  prcomp_element <- prcomp(select_if(wd[1:30], is.numeric), scale = TRUE, center = TRUE)

  ellipse_color <- as.vector(viridis(n = length(levels(input_df[[groups]]))))
  
  autoplot(prcomp_element, data = input_df,
           colour = 'treatment',
           loadings = TRUE,
           loadings.colour =  "black",
           loadings.label = TRUE,
           loadings.label.size = 2,
           loadings.label.colour = "black",
           frame = TRUE,
           frame.type = "norm",
           frame.color = ellipse_color) +
    ggtitle(title = "PCA - Biplot")
    scale_fill_manual(values = ellipse_color) +
    scale_color_manual(values = ellipse_color) +
    my_theme
}

## heatmaps
correlation_heatmap <- function(input_df, interactive = FALSE){
  cor_matrix <- cor(select_if(input_df, is.numeric), method = "spearman")
  melted_cor_matrix <- reshape::melt(cor_matrix)
  # melted_cor_matrix$X1 <- substring(melted_cor_matrix$X1, first = 1, last = 10)
  # melted_cor_matrix$X2 <- substring(melted_cor_matrix$X2, first = 1, last = 10)
  names(melted_cor_matrix) <- c("x", "y", "correlation")
  head(melted_cor_matrix)
  
  cor_heatmap <- ggplot(data = melted_cor_matrix, aes(x=x, y=y, fill=correlation)) +
    geom_tile() +
    ggtitle("Spearman correlation") +
    scale_fill_viridis_c(option = "magma") +
    my_theme +
    theme(axis.title = element_blank(), 
          axis.text.y = element_text(size = 6),
          axis.text.x = element_text(angle = 90, size = 6, hjust = 1))
  
  
  if (interactive == TRUE) {
    plotly::ggplotly(cor_heatmap) # interactive heatmap
  } else {
    cor_heatmap # static heatmap
  }
  
}
