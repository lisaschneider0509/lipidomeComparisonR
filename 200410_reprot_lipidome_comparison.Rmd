---
title: "Meat comparison report"
author: "Lisa Schneider"
date: "April 10, 2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Installation and namespaces
The files with the self-written functions for this workflow are loaded with source(). The first source-file "install_packages_lipidome_comparison.R" contains a function that installs all required packages. The installed packages are loaded into the namespace with library(). 
```{r load_packages, include=TRUE, warning=FALSE, message=FALSE}
source("install_packages_lipidome_comparison.R")
# install_packages_lipidome_comparison() # installs all reqired packages for this workflow 

library(dplyr) # select part of data
library(stringr) # count separators
library(data.table) # transpose data frame
library(imputeLCMD) # various imputation procedures, including left censored imputation
library(impute) # dependecy for imputeLCMD
library(ggplot2) # plots
library(tibble) # data frame manipulation
library(viridis) # colorblind save color schemes
library(GGally) # paralell plot
library(fmsb) # spider chart
library(scales) # scale opacity of filling (alpha)
library(ggrepel) # avoids overlapping labels in ggplot graphs
library(factoextra) # graphs for PCA
library(ggfortify) # biplot with ggplot
library(heatmaply) # interactive heatmap
library(gplots) # heatmap
library(plotly) # interactive ggplots

source("lipidome_comparison_dataTransformaions.R")
source("lipidome_comparison_EDA.R")
source("lipidome_comparison_pca.R")
source("lipidome_comparison_clustering.R")
source("lipidome_comparison_hypothesis_testing.R")

```

```{r set_layout, include=FALSE}
my_theme <- theme_set(
  theme_minimal() +
    theme(plot.title = element_text(size=12, hjust = 0.5, family="AvantGarde"),
          plot.subtitle = element_text(size = 8, hjust = 0.5, family = "AvantGarde", colour = "grey40"),
          axis.text.x = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          axis.text.y = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          axis.title.x = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
          axis.title.y = element_text(size = 10, hjust = 0.5, colour = "grey40", family="AvantGarde"),
          legend.text = element_text(size = 8, colour = "grey40", family="AvantGarde"),
          legend.title = element_text(size = 10, colour = "grey40", family="AvantGarde"))
)
```

## Set directorys
This is set for my system. The syntax for windows is slightly different. Making this work on all systems, maybe from command line is planned for later. 

```{r set_paths}
working_directory <- "/home/lisa/FH/Masterarbeit/LipidomeComparison"
setwd(working_directory)

test_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/Probe-Datensatz_lisa.csv"
meat_data_path <- "/home/lisa/FH/Masterarbeit/LipidomeComparison/data/meat_fish_final_raw.csv"

plot_path <- paste(working_directory, "/plots", sep = "")
plot_name <- paste(plot_path, "/meat_data", sep = "")
```

## A lot of data preprocessing
The meat data was used without preprocessing, except exproting the excel sheet to csv. The data was read from csv to the script and stripped of meta data. The string "N/F" for not identified lipids was replaced with NA and the data was separated in target data and internal standard data. The target data was then re-formatted, with the compounds as the columns and the sample IDs as the rows. The used function flip_df()  is from the "lipidome_comparison_dataTransformaions.R" file. 
Metadata was extracted from the sample IDs and the data set was separated by extraction method (AS and N). 

```{r data_preprocessing}
meat_data <- read.csv(meat_data_path, sep = ",", dec = ".", header = TRUE)
meat_data <- subset(meat_data, select = c(Compound, Type, Filename, Status, Group, Area))
meat_data <- subset(meat_data, Status == "Processed")
meat_data[meat_data==''] <- NA
meat_data[meat_data=='N/F'] <- NA
meat_data$Area <- as.numeric(meat_data$Area)
meat_target <- subset(meat_data, Type == "Target Compound")
meat_standard <- subset(meat_data, Type == "Internal Standard")

meat_target <- flip_df(meat_target)

meat_target <- subset(meat_target, !is.na(Group))
meat_target$SID <- sub(".*probe","sample", meat_target$SID)
meat_target$SID <- sub("\\.*pos2","2", meat_target$SID)
meat_target$SID <- sub("\\.*pos","1", meat_target$SID)

meat_AS <- meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] 
meat_target$SID[str_detect(meat_target$SID, "AS") == TRUE] <- sub(".*sample","AS_sample", meat_AS)
meat_N <- meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] 
meat_target$SID[str_detect(meat_target$SID, "AS") == FALSE] <- sub(".*sample","N_sample", meat_N)
meat_target$SID <- str_remove(meat_target$SID, "_AS")

meta_info <- read.table(text = meat_target$SID, sep = "_")
colnames(meta_info) <- c("Treatment", "Sample_nr", "Biol_rep", "Tech_rep")
meta_info$Biol_rep <- paste(meta_info$Sample_nr, meta_info$Biol_rep, sep = "_")
meta_info$Tech_rep <- paste(meta_info$Biol_rep, meta_info$Tech_rep, sep = "_")

meat_target <- cbind(meat_target$SID, meta_info, meat_target[, -1])
meat_target <- droplevels(meat_target)
levels(meat_target$Group)[levels(meat_target$Group) == "fleisch"] <- "meat"
levels(meat_target$Group)[levels(meat_target$Group) == "wild"] <- "game"
levels(meat_target$Group)[levels(meat_target$Group) == "FISCH"] <- "fish"
colnames(meat_target) <- c("SID", colnames(meat_target[-1]))
head(meat_target[1:7], 3)
meat_N <- subset(meat_target, Treatment == "N")
meat_AS <- subset(meat_target, Treatment == "AS")
```

## Data imputation
It can be assumed that most of the missing values are due to the concentration being below the detection limit. Therefore the missing values are considdered non-random and left-censored. 
Imputation only works up to a certain percentage of missing values, without changing the results. I found 20% missing values in the literature (Gurke, 2019, doi: 10.3389/fpsyt.2019.00041), therefore all compounds with more than 20% missing values were filtered. 
The remaining missing values where imputed using the QRILC (Quantile Regression Imputation of Left-Censored data) procedure. This procedure has the disadvantage of producing negative values (because it performs random draws from a distribution), which is a problem for the calculation of the log2 foldchange (I'm working on that). 

```{r imputation}
# remove columns where > 20% of the values are missing
impute_meat <- meat_N[, which(colMeans(!is.na(meat_N)) > 0.8)] 
impute_meat <- as.matrix(select_if(impute_meat, is.numeric))

# perform missing data imputation
meat_QRILC <- impute.QRILC(impute_meat, tune.sigma = 1) #todo constraints agains negative values
meat_imputed <- as.data.frame(meat_QRILC[[1]])
meat_imputed <- cbind(meat_N[, 1:6], meat_imputed)
meat_imputed <- droplevels(meat_imputed) # remove unused levels from factors
head(meat_imputed[1:7], 3)
```

## Reducing the replicates
To not artificially produce more samples than we hat and to reduce variation in preprocessing and measurement the means for each sample or biological replicate are calculated. 
The idea is, to continue working with these values, but in most cases this reduces the sample number below a point where most procedures work (n[fish] = 1 ). So in the for now I continued working with the non reduced data.  
The self-wirtten functions in this part are in "lipidome_comparison_dataTransformaions.R" and "lipidome_comparison_EDA.R".

```{r replicate redunction}
meat_groups <- generate_categorical_table(meat_imputed$Group) 
meat_treatment <- generate_categorical_table(meat_imputed$Treatment)

meat_numeric <- meat_imputed
meat_numeric$Group <- as.numeric(meat_numeric$Group)
meat_biol <- calc_by_replicate(meat_numeric, meat_numeric$Sample_nr, mean)
meat_tech <- calc_by_replicate(meat_numeric, meat_numeric$Biol_rep, mean)

new_meat_biol <- paste_catecorical_variable(meat_biol, 2, meat_groups)
head(new_meat_biol[1:7], 3)
new_meat_biol <- paste_catecorical_variable(meat_tech, 2, meat_groups)
head(new_meat_biol[1:7], 3)
```

## Exploratory data analysis 
Exploratory data analysis was performed graphically and using the shapiro-wilk test. 
The graphical data analysis (using qqplot, histogram and boxplot) turned out not to be verry practical due to the numer of compounds, but it gives a good overview over the distributions of the variables. It showed, that some of the variables had normal distribution, while others where multi modal. Therefor the results of the following tests for normal distribution and correlation have to be handelled carefully. 
All the graphs are in a separate zip-folder due to thier size and runtime. 

```{r eda_graphical, include=FALSE}
### graphical exploratory data analysis
qqplot_by_factor(meat_imputed, "Group", out_path = plot_name)
histogram_by_factor(meat_imputed, "Group", out_path = plot_name)
boxplot_by_factor(meat_imputed, "Group", out_path = plot_name)
```

```{r eda}
### test for normality
meat_normality <- shapiro_by_factor(meat_imputed, meat_imputed$Group)
head(meat_normality[1:7], 3)

### test for correlation
meat_correlation <- cor(select_if(meat_imputed, is.numeric), method = "spearman")
head(meat_correlation[1:7], 3)
correlation_heatmap(meat_imputed, interactive = FALSE)
```

Some additional graphs for EDA: 
These graphs only make sense when comparing a specific part of the data set. Therefor I slices where only LPC is compared. In the paralell plot we can see, that there is a small variation between the fish samples (which makes sense, because they are only technical replicates) and more variation in the meat and game samples. A separation by group is not visible in any of the variables (including those not shown in the plot). 
```{r graphs}
parallel_plot(meat_imputed[1:27], meat_imputed$Group)
meat_spider <- calc_by_replicate(meat_imputed, meat_imputed$Group, mean)
spider_chart(meat_spider[,1:22], legend_lab = meat_spider$Group.1)
```

## Principal component analysis
The selection of the number of principal components depends on the explained variance displayed by get_eigenvalue() and the scree plots. There are two different representations of the scree plots, because I find both of them useful. Unfortunately in our data eacah PC only explains a small percentage of variance, PC1 and PC2 together explain only about 36%, therefore this model is not ideal. 
We can also see the problem with the separation in the biplots. While the fish-values are close together (due to them being replicates of the same sample), there is almost no separation between meat and game. 

```{r PCA}
meat_pca <- PCA(select_if(meat_imputed, is.numeric), scale.unit = TRUE, graph = FALSE)
meat_eigenvalue <- get_eigenvalue(meat_pca)
meat_eigenvalue

scree_factoextra(meat_pca)
scree_base(select_if(meat_imputed, is.numeric))

biplot_ggplot2(meat_imputed, "Group", loadings = FALSE, ellipse = TRUE, scale = TRUE)
biplot_factoextra(meat_pca, meat_imputed$Group, ellipse = TRUE)

plot_contrib_to_pc(meat_pca, out_path = plot_name)

fviz_contrib(meat_pca, choice = "var", axes = 1, top = 10, 
             fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3), 
             ggtheme = my_theme)
fviz_contrib(meat_pca, choice = "var", axes = 2, top = 10, 
             fill = viridis(n = 1, begin = 0.3), color = viridis(n = 1, begin = 0.3), 
             ggtheme = my_theme, 
             linecolor = "black")
```
